# Tech Stack Decisions & Selection

> **Version:** 2.0.0 | **Category:** Cat 4 (Patterns R√©utilisables) | **Difficulty:** Intermediate
> **Auto-Activation:** "which tech", "tech stack", "choose", "framework", "library", "vs", "or", "quel stack"
> **Tags:** [tech-decisions, stack, framework, choice, comparison]
> **Related:** nextjs-patterns, nestjs-patterns, rust-axum
> **Last Updated:** 2025-02-24

---

## üéØ Decision Matrix Quick Reference

| Requirement | Stack | When to Use |
|-------------|-------|-------------|
| **Full-stack SSR app** | Next.js 16 + Prisma + Vercel | SSR/SSG needed, Vercel deploy |
| **Type-safe SPA** | TanStack Start + Query/Router/Form | 100% type-safe routing |
| **High-performance API** | Rust + Axum + PostgreSQL | Max performance, type safety |
| **Simple prototype** | Vite + React + Zustand + Supabase | Quick MVP, minimal setup |
| **Enterprise app** | Next.js + Drizzle + PostgreSQL + AWS | Complex requirements, control |
| **Real-time app** | NestJS + Socket.io + Redis | WebSockets, complex backend |
| **SaaS platform** | Next.js + Stripe + Prisma + Vercel | Subscription, payments |
| **WASM app** | Rust + Axum + WebAssembly (wasm-bindgen) | High-performance compute in browser |

---

## üñ•Ô∏è Frontend Framework Decision

### Next.js 16

**Use when:**
- ‚úÖ SSR/SSG/ISR needed
- ‚úÖ Vercel deployment
- ‚úÖ Server Components (RSC)
- ‚úÖ Built-in API routes (webhooks only)
- ‚úÖ File-based routing

**Key Features:**
- App Router + RSC
- Cache Components (`use cache`)
- Tag-based invalidation (`revalidateTag`)
- Turbopack default in production
- React 19.2 support

**Avoid when:**
- ‚ùå 100% type-safe routing needed ‚Üí Use TanStack Start
- ‚ùå Need framework-agnostic ‚Üí Use Vite

### TanStack Start

**Use when:**
- ‚úÖ 100% type-safe routing everywhere
- ‚úÖ Advanced data loading
- ‚úÖ TanStack ecosystem (Query/Router/Form)
- ‚úÖ Framework-agnostic deployment

**Key Features:**
- File-based + code-based routing
- Type-safe search params
- Type-safe loaders
- Integrated with TanStack Query

### Vite + React

**Use when:**
- ‚úÖ SPA only (no SSR)
- ‚úÖ Maximum flexibility
- ‚úÖ Custom backend (Rust, Go)
- ‚úÖ Fastest build times

**Avoid when:**
- ‚ùå SSR needed ‚Üí Use Next.js
- ‚ùå Built-in backend ‚Üí Use Next.js

### Angular

**Use when:**
- ‚úÖ Enterprise apps with large teams
- ‚úÖ Full-framework ecosystem needed
- ‚úÖ TypeScript-first
- ‚úÖ Structured dependency injection

**Avoid when:**
- ‚ùå Small projects ‚Üí Overkill
- ‚ùå Quick prototype ‚Üí Slower DX

---

## üì¶ State Management Decision

```
Server Data  ‚Üí TanStack Query (ALWAYS)
Form State   ‚Üí TanStack Form or React Hook Form
UI State     ‚Üí Zustand
URL State    ‚Üí Framework router
Server State ‚Üí Server Components (no client state)
```

### TanStack Query

**Use for:**
- ‚úÖ Server data fetching
- ‚úÖ Caching
- ‚úÖ Background refetch
- ‚úÖ Optimistic updates
- ‚úÖ Pagination/infinite scroll

**Example:**
```typescript
const { data, isLoading, error } = useQuery({
  queryKey: ['posts', page],
  queryFn: () => fetchPosts(page),
  staleTime: 5 * 60 * 1000, // 5 min
})
```

### Zustand

**Use for:**
- ‚úÖ UI state (modals, sidebars, themes)
- ‚úÖ Client-side cache
- ‚úÖ Simple global state
- ‚úÖ Form state (small forms)

**Avoid for:**
- ‚ùå Server data ‚Üí Use TanStack Query
- ‚ùå Complex time-travel ‚Üí Use Redux Toolkit

**Example:**
```typescript
const useStore = create((set) => ({
  sidebarOpen: false,
  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen }))
}))
```

### Redux Toolkit

**Use for:**
- ‚úÖ Large-scale apps
- ‚úÖ Time-travel debugging needed
- ‚úÖ Complex state relationships
- ‚úÖ Middleware required

**Avoid for:**
- ‚ùå Simple apps ‚Üí Overkill

---

## üîß Backend Decision

### Node.js + NestJS

**Use when:**
- ‚úÖ Team knows JavaScript/TypeScript
- ‚úÖ Quick prototyping
- ‚úÖ I/O-bound operations
- ‚úÖ Microservices architecture
- ‚úÖ Real-time (WebSocket)
- ‚úÖ Structured, enterprise-style framework

**NestJS Features:**
- TypeScript-first
- Dependency injection
- Modules architecture
- Built-in validation (class-validator)
- Guards, interceptors, pipes
- Excellent for large teams

### Rust + Axum

**Use when:**
- ‚úÖ Maximum performance
- ‚úÖ Complex business logic (DDD)
- ‚úÖ Memory constraints
- ‚úÖ Type safety critical
- ‚úÖ Zero-cost abstractions

**Axum Features:**
- Ergonomic router
- Extractor system
- Tower middleware
- Async/await first
- Memory safe

### Go

**Use when:**
- ‚úÖ High concurrency needs
- ‚úÖ Simple, fast services
- ‚úÖ Team knows Go
- ‚úÖ Cloud-native apps
- ‚úÖ Standard library preference

---

## üóÑÔ∏è Database Decision

### PostgreSQL

**Use when:**
- ‚úÖ Complex relations
- ‚úÖ Full-text search needed
- ‚úÖ ACID transactions required
- ‚úÖ JSONB flexibility useful
- ‚úÖ Geospatial data (PostGIS)

**Best ORM:** Prisma or Drizzle

### MySQL

**Use when:**
- ‚úÖ Existing MySQL infrastructure
- ‚úÖ Simpler needs
- ‚úÖ Team familiarity

### MongoDB

**Use when:**
- ‚úÖ Flexible schema required
- ‚úÖ Document-based data model
- ‚úÖ Horizontal scaling priority
- ‚úÖ JSON-heavy data

**Avoid when:**
- ‚ùå Complex relations ‚Üí Use PostgreSQL
- ‚ùå ACID critical ‚Üí Use PostgreSQL

### SQLite

**Use when:**
- ‚úÖ Embedded database needed
- ‚úÖ Simple data model
- ‚úÖ Single-instance app
- ‚úÖ Testing/local development

---

## üîå ORM Decision

### Prisma

**Use when:**
- ‚úÖ Type safety critical
- ‚úÖ Schema migrations needed
- ‚úÖ Complex relations
- ‚úÖ TypeScript project
- ‚úÖ Great DX required

**Example:**
```typescript
const user = await prisma.user.findUnique({
  where: { id: userId },
  include: { posts: true }
})
```

### Drizzle

**Use when:**
- ‚úÖ SQL-like API needed
- ‚úÖ Smaller bundle size
- ‚úÖ No migrations needed
- ‚úÖ Performance critical
- ‚úÖ Maximum type safety

**Example:**
```typescript
const user = await db.select().from(users).where(eq(users.id, userId))
```

### sqlx (Rust)

**Use when:**
- ‚úÖ Compile-time verification
- ‚úÖ Raw SQL performance
- ‚úÖ Rust project
- ‚úÖ No ORM overhead

---

## üß™ Testing Decision

```
Unit/Integration ‚Üí Vitest (fast, native ESM)
E2E              ‚Üí Playwright (cross-browser, fast)
Visual Regression ‚Üí Chromatic or Percy
Load Testing      ‚Üí k6 or Artillery
```

### Vitest

**Use when:**
- ‚úÖ Unit tests
- ‚úÖ Integration tests
- ‚úÖ Fast feedback needed
- ‚úÖ Vite project

### Playwright

**Use when:**
- ‚úÖ E2E tests
- ‚úÖ Cross-browser testing
- ‚úÖ User flow testing

---

## üöÄ Deployment Decision

### Vercel

**Use when:**
- ‚úÖ Next.js project
- ‚úÖ Zero-config deployment
- ‚úÖ Edge functions needed
- ‚úÖ Preview deployments
- ‚úÖ Automatic HTTPS

### AWS

**Use when:**
- ‚úÖ Existing AWS infrastructure
- ‚úÖ Full control needed
- ‚úÖ Complex requirements
- ‚úÖ Cost optimization at scale
- ‚úÖ Multi-region

### Docker

**Use when:**
- ‚úÖ Consistency across environments
- ‚úÖ Self-hosted
- ‚úÖ Microservices
- ‚úÖ On-premise deployment

---

## üåê Real-Time Decision

### WebSockets

| Solution | Use When |
|----------|----------|
| **Socket.io** | Node.js, fallbacks needed |
| **ws** | Node.js, simple WebSockets |
| **Socketize** | Rust, Axum |
| **SignalR** | .NET backend |

### Server-Sent Events (SSE)

**Use when:**
- ‚úÖ One-way communication (server ‚Üí client)
- ‚úÖ Simpler than WebSockets
- ‚úÖ Auto-reconnect needed

---

## üì¶ API Decision

### REST

**Use when:**
- ‚úÖ Standard CRUD operations
- ‚úÖ Simple caching (HTTP)
- ‚úÖ Stateless

### GraphQL

**Use when:**
- ‚úÖ Complex data relationships
- ‚úÖ Multiple clients with different needs
- ‚úÖ Flexible queries needed

### tRPC

**Use when:**
- ‚úÖ TypeScript end-to-end
- ‚úÖ Next.js full-stack
- ‚úÖ No schema duplication

---

## üé® Styling Decision

| Solution | Use When |
|----------|----------|
| **Tailwind CSS** | Utility-first, rapid UI dev |
| **CSS Modules** | Component-scoped, traditional |
| **Styled Components** | CSS-in-JS, React |
| **shadcn/ui** | Copy-paste, Radix primitives |

---

## üîê Authentication Decision

| Solution | Use When |
|----------|----------|
| **NextAuth.js** | Next.js, OAuth providers |
| **Clerk** | Drop-in auth, great UX |
| **Lucia** | Framework-agnostic, lightweight |
| **Supabase Auth** | Supabase ecosystem |

---

## ‚ö° WebAssembly Decision

### When to Use WebAssembly

| Use Case | Stack | Why |
|----------|-------|-----|
| **High-performance compute** | Rust + wasm-bindgen | Near-native speed |
| **Image/Video processing** | Rust + WASM + Workers | Offload main thread |
| **Cryptography** | Rust + WASM | Secure, fast |
| **Games/Physics** | Rust + WASM | Performance critical |
| **Data visualization** | Rust + WASM | Large dataset processing |
| **Audio processing** | Rust + WASM | Real-time processing |

### When NOT to Use WASM

‚ùå **Avoid for:**
- Simple DOM manipulation ‚Üí JS is fine
- Basic CRUD ‚Üí No performance gain
- Small apps ‚Üí Overhead of WASM > benefits
- Team doesn't know Rust ‚Üí Learning curve

---

## ‚ö†Ô∏è Anti-Patterns

| ‚ùå NEVER | ‚úÖ ALWAYS | Why |
|---------|-----------|-----|
| Choosing tech based on hype | Project requirements first | Hype fades, requirements remain |
| Using 10+ libraries for simple tasks | Minimal dependencies | Complexity overhead |
| Switching tech mid-project | Proper research upfront | Expensive context switch |
| Ignoring team expertise | Team skills match | Learning curve delays |
| Not considering long-term maintenance | Sustainability | Technical debt accumulates |
| Analysis paralysis | Informed decisions with cutoff | Perfection is enemy of good |

---

## üîß Troubleshooting

| Problem | Cause | Solution |
|---------|-------|----------|
| **"Tech choice feels wrong"** | Insufficient research | Re-evaluate requirements vs tech capabilities |
| **"Team can't learn tech"** | Too steep learning curve | Consider training or alternative |
| **"Performance issues"** | Wrong tech for use case | Profile before choosing, benchmark after |
| **"Integration nightmare"** | Incompatible choices | Verify ecosystem compatibility early |
| **"Regretting choice later"** | Short-term thinking | Consider 6-12 month roadmap |

---

## üîó Related Skills

- **Related:** All pattern skills - Detailed tech-specific patterns
- **Related:** `nextjs-patterns` - When to choose Next.js
- **Related:** `rust-axum` - When to choose Rust
- **Related:** `nestjs-patterns` - When to choose NestJS

---

## üìñ Further Reading

- [Technology Radar](https://www.thoughtworks.com/radar) - Tech assessment guide
- [StackShare](https://stackshare.io) - Real tech stacks from companies
- [Choose Boring Technology](https://mcfunley.com/2016/04/22/choose-boring-technology.html)

---

## üéØ Success Criteria

Tech decision process is complete when:
- [ ] Requirements clearly defined
- [ ] Options evaluated (2-3 alternatives)
- [ ] Team expertise considered
- [ ] Long-term viability assessed
- [ ] Proof-of-concept tested if needed
- [ ] Team agrees on decision
- [ ] Migration plan documented (if applicable)
- [ ] Success metrics defined

---

## üí° Key Insights

### Why Tech Decisions Matter

1. **Long-term Impact** - Choices affect years of development
2. **Team Productivity** - Right tools = happy, productive team
3. **Maintenance Cost** - Good choices reduce technical debt
4. **Scalability** - Tech must handle growth
5. **Ecosystem** - Available libraries and community support

### Common Pitfalls

- ‚ùå **Pitfall:** Choosing based on trends
  ‚Üí **Fix:** Focus on requirements and team skills

- ‚ùå **Pitfall:** Analysis paralysis
  ‚Üí **Fix:** Set decision deadline, move forward

- ‚ùå **Pitfall:** Ignoring maintenance
  ‚Üí **Fix:** Consider long-term support and updates

---

*Version: 2.0.0 | Tech Stack Decisions*
