# Next.js 16 Patterns & Best Practices

> **Version:** 1.0.0 | **Category:** TrigMem Cat 4 (Patterns RÃ©utilisables)
> **Trigger:** "Server Action", "App Router", "RSC", "revalidateTag", "use cache"

---

## ğŸš€ Quick Start

```bash
npx create-next-app@latest my-app --typescript --tailwind --eslint
cd my-app
npm run dev
```

---

## ğŸ“ Project Structure

```
src/
â”œâ”€â”€ app/                      # App Router (routing only)
â”‚   â”œâ”€â”€ (auth)/              # Route groups (no URL segment)
â”‚   â”‚   â”œâ”€â”€ login/
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â”‚   â””â”€â”€ layout.tsx
â”‚   â”œâ”€â”€ (dashboard)/
â”‚   â”œâ”€â”€ api/                 # API routes (webhooks only)
â”‚   â”‚   â””â”€â”€ webhooks/
â”‚   â”‚       â””â”€â”€ stripe/
â”‚   â”‚           â””â”€â”€ route.ts
â”‚   â”œâ”€â”€ layout.tsx           # Root layout
â”‚   â”œâ”€â”€ page.tsx             # Home page
â”‚   â”œâ”€â”€ loading.tsx          # Global loading
â”‚   â””â”€â”€ error.tsx            # Global error
â”‚
â”œâ”€â”€ features/                # Business logic
â”‚   â””â”€â”€ [feature]/
â”‚       â”œâ”€â”€ components/
â”‚       â”œâ”€â”€ hooks/
â”‚       â”œâ”€â”€ actions/         # Server actions
â”‚       â””â”€â”€ types.ts
â”‚
â””â”€â”€ ui/                      # Presentational components
    â””â”€â”€ atoms/
```

---

## ğŸ¯ Server vs Client Components

### Default: Server Component

```typescript
// âœ… GOOD - Server Component (default)
import { db } from '@/lib/db'

export default async function PostsPage() {
  const posts = await db.post.findMany()
  return <PostList posts={posts} />
}
```

**Use for:**
- âœ… Data fetching
- âœ… Direct database access
- âœ… Keeping secrets safe
- âœ… Reducing client JS

### Client Component with 'use client'

```typescript
// âœ… GOOD - Client Component
'use client'

import { useState } from 'react'

export function Counter() {
  const [count, setCount] = useState(0)
  return <button onClick={() => setCount(c => c + 1)}>{count}</button>
}
```

**Use for:**
- âœ… Hooks (useState, useEffect, etc.)
- âœ… Event handlers
- âœ… Browser APIs
- âœ… Interactive UI

### Pattern: Server Parent, Client Child

```typescript
// Server Component
import { Counter } from '@/ui/atoms/counter'

export default async function Page() {
  const initialCount = await getInitialCount()
  return <Counter initialCount={initialCount} />
}

// Client Component
'use client'
export function Counter({ initialCount }: { initialCount: number }) {
  const [count, setCount] = useState(initialCount)
  // ...
}
```

---

## ğŸ”¥ Server Actions (Next.js 16)

### Basic Server Action

```typescript
// features/posts/actions/create-post.ts
'use server'

import { z } from 'zod'
import { db } from '@/lib/db'
import { revalidateTag } from 'next/cache'

const schema = z.object({
  title: z.string().min(1),
  content: z.string().min(1),
})

export async function createPost(formData: FormData) {
  const data = schema.parse({
    title: formData.get('title'),
    content: formData.get('content'),
  })

  const post = await db.post.create({ data })

  // Revalidate cache
  revalidateTag('posts')
  // OR revalidate path
  // revalidatePath('/posts')

  return post
}
```

### Server Action with TypeScript

```typescript
'use server'

import { revalidateTag } from 'next/cache'

type CreatePostInput = {
  title: string
  content: string
}

export async function createPost(input: CreatePostInput) {
  const post = await db.post.create({ data: input })
  revalidateTag('posts')
  return post
}
```

### Using Server Actions in Forms

```typescript
'use client'

import { createPost } from '@/features/posts/actions/create'

export function CreatePostForm() {
  async function handleSubmit(formData: FormData) {
    await createPost(formData)
  }

  return (
    <form action={handleSubmit}>
      <input name="title" />
      <textarea name="content" />
      <button type="submit">Create</button>
    </form>
  )
}
```

### Server Action with useActionState

```typescript
'use client'

import { useActionState } from 'react'
import { createPost } from '@/features/posts/actions/create'

export function CreatePostForm() {
  const [state, formAction, isPending] = useActionState(createPost, null)

  return (
    <form action={formAction}>
      <input name="title" disabled={isPending} />
      <button type="submit" disabled={isPending}>
        {isPending ? 'Creating...' : 'Create'}
      </button>
      {state?.error && <p>{state.error}</p>}
    </form>
  )
}
```

---

## ğŸ·ï¸ Cache Components (Next.js 16)

### Basic Cache Component

```typescript
// features/posts/queries/get-posts.ts
async function getPosts() {
  'use cache'
  cacheTag('posts')

  return db.post.findMany()
}
```

### Cache with Tags

```typescript
import { unstable_cacheTag as cacheTag } from 'next/cache'

async function getPost(id: string) {
  'use cache'
  cacheTag('posts', `post-${id}`)

  return db.post.findUnique({ where: { id } })
}
```

### Invalidate Cache

```typescript
'use server'

import { revalidateTag } from 'next/cache'
import { db } from '@/lib/db'

export async function updatePost(id: string, data: any) {
  await db.post.update({ where: { id }, data })
  revalidateTag('posts')        // Invalidate all posts
  revalidateTag(`post-${id}`)  // Invalidate specific post
}
```

---

## ğŸ“¡ Data Fetching Patterns

### Server Component Data Fetching

```typescript
// app/posts/page.tsx
import { getPosts } from '@/features/posts/queries/get-posts'

export default async function PostsPage() {
  const posts = await getPosts()
  return <PostList posts={posts} />
}
```

### TanStack Query in Client Components

```typescript
// features/posts/hooks/use-posts.ts
'use client'

import { useQuery } from '@tanstack/react-query'

export function usePosts() {
  return useQuery({
    queryKey: ['posts'],
    queryFn: async () => {
      const res = await fetch('/api/posts')
      return res.json()
    },
  })
}
```

### Hybrid: Server Component + TanStack Query

```typescript
// Server Component provides initial data
export default async function PostsPage() {
  const posts = await getPosts()
  return <PostsClient initialData={posts} />
}

// Client Component hydrates with TanStack Query
'use client'
import { useQuery } from '@tanstack/react-query'

export function PostsClient({ initialData }: { initialData: Post[] }) {
  const { data } = useQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
    initialData,
  })
  // ...
}
```

---

## ğŸ”— Route Handlers (API Routes)

**Use ONLY for:**
- âœ… Webhooks (Stripe, GitHub, etc.)
- âœ… Third-party integrations
- âœ… Non-web applications

**NOT for:**
- âŒ Regular data fetching â†’ Use Server Components/Actions

### Webhook Handler

```typescript
// app/api/webhooks/stripe/route.ts
import { headers } from 'next/headers'
import Stripe from 'stripe'

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!)

export async function POST(req: Request) {
  const body = await req.text()
  const signature = headers().get('stripe-signature')!

  const event = stripe.webhooks.constructEvent(
    body,
    signature,
    process.env.STRIPE_WEBHOOK_SECRET!
  )

  if (event.type === 'checkout.session.completed') {
    // Handle checkout completion
  }

  return Response.json({ received: true })
}
```

---

## ğŸ¨ Layouts & Templates

### Root Layout

```typescript
// app/layout.tsx
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'My App',
  description: 'Built with Next.js',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  )
}
```

### Route Groups

```
app/
â”œâ”€â”€ (auth)/              # No URL segment
â”‚   â”œâ”€â”€ login/
â”‚   â””â”€â”€ register/
â”œâ”€â”€ (dashboard)/         # No URL segment
â”‚   â”œâ”€â”€ layout.tsx       # Shared layout
â”‚   â””â”€â”€ page.tsx
â””â”€â”€ (marketing)/         # No URL segment
    â”œâ”€â”€ about/
    â””â”€â”€ pricing/
```

---

## âš¡ Performance Patterns

### Dynamic Imports

```typescript
import dynamic from 'next/dynamic'

const HeavyComponent = dynamic(
  () => import('@/components/HeavyComponent'),
  { loading: () => <p>Loading...</p> }
)

export default function Page() {
  return <HeavyComponent />
}
```

### Image Optimization

```typescript
import Image from 'next/image'

export function Avatar({ src }: { src: string }) {
  return (
    <Image
      src={src}
      alt="Avatar"
      width={40}
      height={40}
      className="rounded-full"
    />
  )
}
```

### Font Optimization

```typescript
import { Inter } from 'next/font/google'

const inter = Inter({
  subsets: ['latin'],
  display: 'swap',
})
```

---

## ğŸ”’ Security Best Practices

### Environment Variables

```typescript
// .env.local
DATABASE_URL="postgresql://..."
API_SECRET="..."

// Server-only
const dbUrl = process.env.DATABASE_URL

// Client-accessible (must start with NEXT_PUBLIC_)
const apiUrl = process.env.NEXT_PUBLIC_API_URL
```

### Input Validation with Zod

```typescript
import { z } from 'zod'

const postSchema = z.object({
  title: z.string().min(1).max(100),
  content: z.string().min(1),
})

export async function createPost(formData: FormData) {
  const data = postSchema.parse({
    title: formData.get('title'),
    content: formData.get('content'),
  })
  // Safe to use `data`
}
```

---

## ğŸ§ª Testing Patterns

### Server Action Test

```typescript
import { describe, it, expect } from 'vitest'
import { createPost } from './create-post'

describe('createPost', () => {
  it('should create a post', async () => {
    const formData = new FormData()
    formData.set('title', 'Test')
    formData.set('content', 'Content')

    const result = await createPost(formData)

    expect(result).toHaveProperty('id')
  })
})
```

---

## ğŸ“š Common Patterns

### Parallel Data Fetching

```typescript
async function getData() {
  const [posts, users, comments] = await Promise.all([
    getPosts(),
    getUsers(),
    getComments(),
  ])

  return { posts, users, comments }
}
```

### Error Handling

```typescript
// app/error.tsx (client)
'use client'

export default function Error({
  error,
  reset,
}: {
  error: Error
  reset: () => void
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={reset}>Try again</button>
    </div>
  )
}

// app/posts/error.tsx (scoped)
```

### Loading States

```typescript
// app/posts/loading.tsx
export default function Loading() {
  return <Skeleton className="h-4 w-full" />
}
```

---

## ğŸ¯ Best Practices Checklist

- [ ] Use Server Components by default
- [ ] Use Server Actions for mutations
- [ ] Use TanStack Query for client data
- [ ] Use cacheTag/revalidateTag for caching
- [ ] Validate inputs with Zod
- [ ] Keep secrets server-side only
- [ ] Use dynamic imports for heavy components
- [ ] Optimize images with next/image
- [ ] Use route groups for shared layouts
- [ ] Test server actions with vitest

---

*Version: 1.0.0 | TrigMem Cat 4*
