# Rust + WebAssembly Patterns & Best Practices

> **Version:** 2.0.0 | **Category:** Cat 4 (Patterns R√©utilisables) | **Difficulty:** Advanced
> **Auto-Activation:** "wasm", "webassembly", "rust wasm", "wasm-bindgen", "wasm-pack", "performance"
> **Tags:** [wasm, webassembly, rust, performance, optimization]
> **Related:** rust-axum, typescript-patterns, nextjs-patterns
> **Last Updated:** 2025-02-24

---

## üöÄ Quick Start

```bash
# Create new WASM package
cargo new --lib my-wasm-lib
cd my-wasm-lib

# Add WASM dependencies
cargo add wasm-bindgen wasm-bindgen-rayon js-sys web-sys

# Build
wasm-pack build --target web

# Or in Next.js project
npm install wasm-pack
```

### Cargo.toml Configuration

```toml
[package]
name = "my-wasm-lib"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
wasm-bindgen = "0.2"
js-sys = "0.3"
web-sys = "0.3"

# Optional: For parallel processing
wasm-bindgen-rayon = { version = "1.1", optional = true }

[dependencies.wee_alloc]
version = "0.4.5"
optional = true

[features]
default = ["wee_alloc"]

# Optimize for size
[profile.release]
opt-level = "z"
lto = true
codegen-units = 1
```

---

## üìÅ Project Structure

```
my-wasm-lib/
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ lib.rs              # Main entry point
‚îÇ   ‚îú‚îÄ‚îÄ utils.rs            # Utility functions
‚îÇ   ‚îî‚îÄ‚îÄ processing.rs       # Core logic
‚îú‚îÄ‚îÄ pkg/                    # Generated by wasm-pack
‚îÇ   ‚îú‚îÄ‚îÄ my_wasm_lib.js
‚îÇ   ‚îú‚îÄ‚îÄ my_wasm_lib_bg.wasm
‚îÇ   ‚îî‚îÄ‚îÄ my_wasm_lib.d.ts
‚îî‚îÄ‚îÄ www/                    # For testing
    ‚îú‚îÄ‚îÄ index.html
    ‚îú‚îÄ‚îÄ package.json
    ‚îî‚îÄ‚îÄ index.js
```

### With Next.js Integration

```
my-nextjs-app/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ WasmComponent.tsx
‚îÇ   ‚îî‚îÄ‚îÄ lib/
‚îÇ       ‚îî‚îÄ‚îÄ wasm/
‚îÇ           ‚îú‚îÄ‚îÄ pkg/        # Generated WASM
‚îÇ           ‚îî‚îÄ‚îÄ loader.ts   # WASM loader
‚îú‚îÄ‚îÄ wasm-lib/               # Rust source
‚îÇ   ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ   ‚îî‚îÄ‚îÄ src/
‚îÇ       ‚îî‚îÄ‚îÄ lib.rs
‚îî‚îÄ‚îÄ package.json
```

---

## üéØ Basic Patterns

### Hello World

```rust
// src/lib.rs
use wasm_bindgen::prelude::*;

// Export a function to JavaScript
#[wasm_bindgen]
pub fn greet(name: &str) -> String {
    format!("Hello, {}!", name)
}

// Export a const
#[wasm_bindgen]
pub const VERSION: &str = "1.0.0";
```

### Using in JavaScript

```typescript
import init, { greet, VERSION } from './my-wasm-lib/pkg'

async function main() {
  await init(); // Always call init first!
  console.log(VERSION); // "1.0.0"
  console.log(greet("World")); // "Hello, World!"
}

main()
```

### Using in React Component

```typescript
// components/WasmComponent.tsx
'use client'

import { useEffect, useState } from 'react'
import init, { greet } from '@/lib/wasm/pkg/my_wasm_lib'

export function WasmComponent() {
  const [message, setMessage] = useState('Loading...')

  useEffect(() => {
    async function loadWasm() {
      await init()
      setMessage(greet('React'))
    }
    loadWasm()
  }, [])

  return <div>{message}</div>
}
```

---

## üìä Working with Complex Data

### Return Objects

```rust
use wasm_bindgen::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[wasm_bindgen]
pub struct Point {
    x: f64,
    y: f64,
}

#[wasm_bindgen]
impl Point {
    #[wasm_bindgen(constructor)]
    pub fn new(x: f64, y: f64) -> Point {
        Point { x, y }
    }

    pub fn distance(&self, other: &Point) -> f64 {
        let dx = self.x - other.x;
        let dy = self.y - other.y;
        (dx * dx + dy * dy).sqrt()
    }
}
```

### Working with Arrays

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn sum_array(numbers: &[f64]) -> f64 {
    numbers.iter().sum()
}

#[wasm_bindgen]
pub fn double_array(numbers: Vec<f64>) -> Vec<f64> {
    numbers.into_iter().map(|x| x * 2.0).collect()
}

// For large arrays, use TypedArrays
#[wasm_bindgen]
pub fn process_float32_array(input: &[f32]) -> Vec<f32> {
    input.iter().map(|x| x * 2.0).collect()
}
```

### JavaScript Interop

```rust
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;

#[wasm_bindgen]
extern "C" {
    // Access browser console
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);

    // Access window
    #[wasm_bindgen(js_namespace = window)]
    fn innerWidth() -> f32;
}

#[wasm_bindgen]
pub fn log_from_rust(message: &str) {
    log(message);
}

#[wasm_bindgen]
pub fn get_window_width() -> f32 {
    innerWidth()
}
```

---

## üßµ Parallel Processing with Rayon

### Setup

```toml
[dependencies]
wasm-bindgen-rayon = "1.1"
rayon = "1.10"
```

### Parallel Processing

```rust
use wasm_bindgen::prelude::*;
use wasm_bindgen_rayon::init_thread_pool;

#[wasm_bindgen]
pub fn init_rayon() {
    init_thread_pool(num_cpus::get());
}

#[wasm_bindgen]
pub fn parallel_process(data: Vec<f64>) -> Vec<f64> {
    use rayon::prelude::*;

    data.par_iter()
        .map(|x| x * x)
        .collect()
}

// Or with slices for better performance
#[wasm_bindgen]
pub fn parallel_process_slice(input: &[f64]) -> Vec<f64> {
    use rayon::prelude::*;

    input.par_iter()
        .map(|x| x.sqrt())
        .collect()
}
```

### JavaScript Integration

```javascript
import init, { init_rayon, parallel_process } from './pkg';

await init();
await init_rayon(); // Must call before parallel functions!

const data = new Float64Array([1, 2, 3, 4, 5]);
const result = parallel_process(data);
```

---

## üñºÔ∏è Image Processing Example

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn grayscale(image_data: &[u8], width: u32, height: u32) -> Vec<u8> {
    let mut result = image_data.to_vec();

    for i in (0..image_data.len()).step_by(4) {
        let r = image_data[i] as f32;
        let g = image_data[i + 1] as f32;
        let b = image_data[i + 2] as f32;

        // Standard grayscale formula
        let gray = (0.299 * r + 0.587 * g + 0.114 * b) as u8;

        result[i] = gray;
        result[i + 1] = gray;
        result[i + 2] = gray;
        // Alpha channel unchanged
    }

    result
}

#[wasm_bindgen]
pub fn invert_colors(image_data: &[u8]) -> Vec<u8> {
    image_data
        .iter()
        .map(|&byte| 255 - byte)
        .collect()
}
```

### Using in React with Canvas

```typescript
'use client'

import { useRef, useEffect } from 'react'
import init, { grayscale } from '@/lib/wasm/pkg/image_processor'

export function ImageEditor() {
  const canvasRef = useRef<HTMLCanvasElement>(null)

  useEffect(() => {
    init()
  }, [])

  const applyGrayscale = async () => {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext('2d')
    if (!ctx) return

    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
    const input = new Uint8Array(imageData.data.buffer)

    // Process in WASM
    const output = await grayscale(input, canvas.width, canvas.height)

    const resultImageData = new ImageData(
      new Uint8ClampedArray(output.buffer),
      canvas.width,
      canvas.height
    )

    ctx.putImageData(resultImageData, 0, 0)
  }

  return (
    <div>
      <canvas ref={canvasRef} width={800} height={600} />
      <button onClick={applyGrayscale}>Apply Grayscale</button>
    </div>
  )
}
```

---

## üì¶ Next.js Integration

### Optimized WASM Loader

```typescript
// lib/wasm/loader.ts
import { useEffect, useState } from 'react'

type WasmModule = {
  readonly memory: WebAssembly.Memory
  readonly [key: string]: any
}

let wasmCache: WasmModule | null = null

export async function loadWasm<T extends WasmModule>(
  modulePath: string,
  initFn: () => Promise<T>
): Promise<T> {
  if (wasmCache) {
    return wasmCache as T
  }

  const module = await initFn()
  wasmCache = module
  return module
}

// React Hook
export function useWasm<T extends WasmModule>(
  modulePath: string,
  initFn: () => Promise<T>
) {
  const [module, setModule] = useState<T | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  useEffect(() => {
    loadWasm(modulePath, initFn)
      .then(setModule)
      .catch(setError)
      .finally(() => setLoading(false))
  }, [modulePath, initFn])

  return { module, loading, error }
}
```

### Usage in Next.js

```typescript
// app/page.tsx
'use client'

import dynamic from 'next/dynamic'

// Disable SSR for WASM
const WasmProcessor = dynamic(
  () => import('@/components/WasmProcessor'),
  { ssr: false }
)

export default function Page() {
  return (
    <main>
      <h1>WASM Image Processing</h1>
      <WasmProcessor />
    </main>
  )
}
```

---

## üéØ Best Practices

### Performance

1. **Minimize JS/Wasm Boundaries**
   - Batch operations
   - Pass arrays instead of individual values
   - Use TypedArrays for large data

2. **Optimize WASM Size**
   ```bash
   # Use wasm-opt to optimize
   wasm-opt pkg/my_wasm_lib_bg.wasm -O4 -o pkg/my_wasm_lib_bg_opt.wasm

   # Enable LTO in Cargo.toml
   [profile.release]
   lto = true
   opt-level = "z"
   ```

3. **Use Shared Memory**
   ```rust
   use wasm_bindgen::prelude::*;

   #[wasm_bindgen]
   pub fn process_shared_memory(ptr: *mut u8, len: usize) {
       let slice = unsafe { std::slice::from_raw_parts_mut(ptr, len) };
       // Process in place
   }
   ```

### Error Handling

```rust
use wasm_bindgen::prelude::*;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum WasmError {
    #[error("Invalid input: {0}")]
    InvalidInput(String),

    #[error("Processing failed")]
    ProcessingFailed,
}

#[wasm_bindgen]
pub fn safe_process(input: &str) -> Result<String, JsValue> {
    if input.is_empty() {
        return Err(WasmError::InvalidInput("Empty input".to_string()).into());
    }
    Ok(input.to_uppercase())
}
```

---

## üéØ Checklist

- [ ] Use `#[wasm_bindgen]` for exported functions
- [ ] Initialize with `await init()` before using
- [ ] Use TypedArrays for large data transfer
- [ ] Minimize JS/Wasm boundary crossings
- [ ] Optimize WASM size with wasm-opt
- [ ] Use Rayon for parallel processing
- [ ] Handle errors with Result types
- [ ] Test in browser (Node.js WASM is different)
- [ ] Disable SSR in Next.js (`ssr: false`)
- [ ] Cache loaded WASM module

---

## üìö Resources

- **wasm-bindgen:** https://rustwasm.github.io/wasm-bindgen/
- **wasm-pack:** https://rustwasm.github.io/wasm-pack/
- **Rust WASM Book:** https://rustwasm.github.io/docs/book/

---

## ‚ö†Ô∏è Anti-Patterns

| ‚ùå NEVER | ‚úÖ ALWAYS | Why |
|---------|-----------|-----|
| Using `wasm-bindgen` for everything | `js-sys` or `web-sys` for browser APIs | Reduces bundle size |
| Ignoring memory management | Proper `Vec`/String handling | Memory leaks |
| Not optimizing WASM size | `wasm-opt` for optimization | Faster loading |
| Synchronous WASM operations | Async with promises | Don't block main thread |
| Not using `wasm-pack` | Proper packaging workflow | Standard tooling |
| Ignoring browser compatibility | Feature detection first | Graceful degradation |

---

## üîß Troubleshooting

| Problem | Cause | Solution |
|---------|-------|----------|
| **"WASM file too large"** | Not optimizing build | Run `wasm-opt` with optimizations |
| **"Memory allocation error"** | Growing memory incorrectly | Use proper `Vec`/String handling |
| **"Function not exported"** | Missing `#[wasm_bindgen]` | Add attribute to exported functions |
| **"Type mismatch error"** | Wrong type conversion | Use proper type mappings |
| **"Performance not improved"** | Wrong use case for WASM | Profile before using WASM |

---

## üîó Related Skills

- **Prerequisite:** `rust-axum` - Rust fundamentals needed
- **Related:** `nextjs-patterns` - Next.js WASM integration
- **Complementary:** `typescript-patterns` - TS types for WASM

---

## üìñ Further Reading

- [Rust WASM Book](https://rustwasm.github.io/docs/book/)
- [wasm-bindgen Guide](https://rustwasm.github.io/wasm-bindgen/)
- [wasm-pack Documentation](https://rustwasm.github.io/wasm-pack/)
- [MDN WebAssembly Docs](https://developer.mozilla.org/en-US/docs/WebAssembly)

---

## üéØ Success Criteria

WASM implementation is complete when:
- [ ] Proper `#[wasm_bindgen]` exports
- [ ] Memory managed correctly (no leaks)
- [ ] WASM size optimized (< 100KB gzipped)
- [ ] Async operations for long tasks
- [ ] TypeScript types generated
- [ ] Error handling across TS/WASM boundary
- [ ] Performance measured and improved
- [ ] Browser compatibility tested

---

## üí° Key Insights

### Why WASM + Rust Works

1. **Near-Native Performance** - Runs at 80-90% of native speed
2. **Memory Safety** - Rust's guarantees prevent entire classes of bugs
3. **Small Bundle** - Optimized WASM is tiny
4. **Type Safety** - Compile-time guarantees
5. **Reuse Existing Code** - Use Rust ecosystem

### Common Pitfalls

- ‚ùå **Pitfall:** Using WASM for everything
  ‚Üí **Fix:** Profile first, use only for performance-critical code

- ‚ùå **Pitfall:** Ignoring memory overhead
  ‚Üí **Fix:** Be mindful of allocations and data transfer

- ‚ùå **Pitfall:** Not optimizing WASM size
  ‚Üí **Fix:** Use `wasm-opt` and enable link-time optimization

---

*Version: 2.0.0 | Rust + WebAssembly Patterns*
