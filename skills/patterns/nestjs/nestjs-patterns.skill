# NestJS Patterns & Best Practices

> **Version:** 2.0.0 | **Category:** Cat 4 (Patterns R√©utilisables) | **Difficulty:** Intermediate
> **Auto-Activation:** "nestjs", "nest", "controller", "service", "module", "decorator", "dependency injection"
> **Tags:** [nestjs, backend, api, typescript, decorators, modules]
> **Related:** typescript-patterns, tech-decisions
> **Last Updated:** 2025-02-24

---

## üöÄ Quick Start

```bash
# New project
npm i -g @nestjs/cli
nest new my-api

# Run
npm run start:dev
```

---

## üìÅ Project Structure

```
src/
‚îú‚îÄ‚îÄ main.ts                 # Entry point
‚îú‚îÄ‚îÄ app.module.ts           # Root module
‚îÇ
‚îú‚îÄ‚îÄ modules/                # Feature modules
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.module.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.controller.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.service.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto/            # Data Transfer Objects
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login.dto.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ register.dto.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ guards/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ jwt-auth.guard.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ strategies/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ jwt.strategy.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ users/
‚îÇ       ‚îú‚îÄ‚îÄ users.module.ts
‚îÇ       ‚îú‚îÄ‚îÄ users.controller.ts
‚îÇ       ‚îú‚îÄ‚îÄ users.service.ts
‚îÇ       ‚îú‚îÄ‚îÄ entities/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ user.entity.ts
‚îÇ       ‚îî‚îÄ‚îÄ dto/
‚îÇ           ‚îî‚îÄ‚îÄ create-user.dto.ts
‚îÇ
‚îú‚îÄ‚îÄ common/                 # Shared utilities
‚îÇ   ‚îú‚îÄ‚îÄ decorators/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ current-user.decorator.ts
‚îÇ   ‚îú‚îÄ‚îÄ filters/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ http-exception.filter.ts
‚îÇ   ‚îú‚îÄ‚îÄ guards/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ roles.guard.ts
‚îÇ   ‚îú‚îÄ‚îÄ interceptors/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ logging.interceptor.ts
‚îÇ   ‚îú‚îÄ‚îÄ pipes/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.pipe.ts
‚îÇ   ‚îî‚îÄ‚îÄ interfaces/
‚îÇ       ‚îî‚îÄ‚îÄ response.interface.ts
‚îÇ
‚îú‚îÄ‚îÄ config/                 # Configuration
‚îÇ   ‚îú‚îÄ‚îÄ app.config.ts
‚îÇ   ‚îî‚îÄ‚îÄ database.config.ts
‚îÇ
‚îî‚îÄ‚îÄ database/               # Database
    ‚îú‚îÄ‚îÄ migrations/
    ‚îî‚îÄ‚îÄ seeds/
```

---

## üéØ Main Entry Point

```typescript
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Global validation pipe
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
    }),
  );

  // CORS
  app.enableCors();

  // Global prefix
  app.setGlobalPrefix('api');

  await app.listen(3000);
}
bootstrap();
```

---

## üì¶ Modules & Controllers

### Auth Module Example

```typescript
// src/modules/auth/auth.module.ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { UsersModule } from '../users/users.module';
import { JwtStrategy } from './strategies/jwt.strategy';

@Module({
  imports: [
    UsersModule,
    PassportModule,
    JwtModule.register({
      secret: process.env.JWT_SECRET,
      signOptions: { expiresIn: '1d' },
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy],
  exports: [AuthService],
})
export class AuthModule {}
```

### Controller

```typescript
// src/modules/auth/auth.controller.ts
import { Controller, Post, Body, UseGuards } from '@nestjs/common';
import { AuthService } from './auth.service';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';
import { JwtAuthGuard } from '../common/guards/jwt-auth.guard';

@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}

  @Post('login')
  async login(@Body() loginDto: LoginDto) {
    return this.authService.login(loginDto);
  }

  @Post('register')
  async register(@Body() registerDto: RegisterDto) {
    return this.authService.register(registerDto);
  }

  @UseGuards(JwtAuthGuard)
  @Post('logout')
  async logout() {
    // Handle logout
    return { message: 'Logged out' };
  }
}
```

### Service

```typescript
// src/modules/auth/auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UsersService } from '../users/users.service';
import { LoginDto } from './dto/login.dto';
import { RegisterDto } from './dto/register.dto';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(
    private readonly usersService: UsersService,
    private readonly jwtService: JwtService,
  ) {}

  async login(loginDto: LoginDto) {
    const user = await this.usersService.findByEmail(loginDto.email);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const isPasswordValid = await bcrypt.compare(
      loginDto.password,
      user.password,
    );
    if (!isPasswordValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const token = this.jwtService.sign({ sub: user.id, email: user.email });
    return { access_token: token };
  }

  async register(registerDto: RegisterDto) {
    const hashedPassword = await bcrypt.hash(registerDto.password, 10);
    const user = await this.usersService.create({
      ...registerDto,
      password: hashedPassword,
    });

    const token = this.jwtService.sign({ sub: user.id, email: user.email });
    return { access_token: token };
  }
}
```

---

## üìù DTOs & Validation

### Using class-validator

```typescript
// src/modules/auth/dto/login.dto.ts
import { IsEmail, IsString, MinLength } from 'class-validator';

export class LoginDto {
  @IsEmail()
  email: string;

  @IsString()
  @MinLength(6)
  password: string;
}

// src/modules/auth/dto/register.dto.ts
import { IsEmail, IsString, MinLength, Matches } from 'class-validator';

export class RegisterDto {
  @IsString()
  @MinLength(2)
  name: string;

  @IsEmail()
  email: string;

  @IsString()
  @MinLength(8)
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, {
    message: 'Password must contain uppercase, lowercase, and number',
  })
  password: string;
}
```

---

## üõ°Ô∏è Guards & Authentication

### JWT Strategy

```typescript
// src/modules/auth/strategies/jwt.strategy.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { UsersService } from '../../users/users.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private readonly usersService: UsersService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: process.env.JWT_SECRET,
    });
  }

  async validate(payload: { sub: number; email: string }) {
    const user = await this.usersService.findById(payload.sub);
    if (!user) {
      throw new UnauthorizedException();
    }
    return user;
  }
}
```

### Custom Decorator for Current User

```typescript
// src/common/decorators/current-user.decorator.ts
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const CurrentUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext) => {
    const request = ctx.switchToHttp().getRequest();
    return request.user;
  },
);

// Usage
@UseGuards(JwtAuthGuard)
@Controller('users')
export class UsersController {
  @Get('me')
  async getProfile(@CurrentUser() user: User) {
    return user;
  }
}
```

### Roles Guard

```typescript
// src/common/guards/roles.guard.ts
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<string[]>('roles', [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requiredRoles) {
      return true;
    }

    const { user } = context.switchToHttp().getRequest();
    return requiredRoles.some((role) => user.roles?.includes(role));
  }
}

// Decorator
export const Roles = (...roles: string[]) => SetMetadata('roles', roles);

// Usage
@Roles('admin')
@UseGuards(JwtAuthGuard, RolesGuard)
@Controller('admin')
export class AdminController {}
```

---

## üóÑÔ∏è Database with TypeORM

### Configuration

```typescript
// src/config/database.config.ts
import { TypeOrmModule } from '@nestjs/typeorm';

export const databaseConfig = TypeOrmModule.forRoot({
  type: 'postgres',
  host: process.env.DB_HOST,
  port: parseInt(process.env.DB_PORT),
  username: process.env.DB_USERNAME,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_DATABASE,
  entities: [__dirname + '/**/*.entity{.ts,.js}'],
  synchronize: false, // Use migrations in production
  migrations: [__dirname + '/../database/migrations/*{.ts,.js}'],
});
```

### Repository Pattern

```typescript
// src/modules/users/users.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { User } from './entities/user.entity';
import { CreateUserDto } from './dto/create-user.dto';

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private readonly usersRepository: Repository<User>,
  ) {}

  async create(createUserDto: CreateUserDto): Promise<User> {
    const user = this.usersRepository.create(createUserDto);
    return await this.usersRepository.save(user);
  }

  async findAll(): Promise<User[]> {
    return await this.usersRepository.find();
  }

  async findById(id: number): Promise<User> {
    const user = await this.usersRepository.findOne({ where: { id } });
    if (!user) {
      throw new NotFoundException(`User #${id} not found`);
    }
    return user;
  }

  async findByEmail(email: string): Promise<User | null> {
    return await this.usersRepository.findOne({ where: { email } });
  }

  async update(id: number, updateUserDto: UpdateUserDto): Promise<User> {
    const user = await this.findById(id);
    Object.assign(user, updateUserDto);
    return await this.usersRepository.save(user);
  }

  async remove(id: number): Promise<void> {
    await this.usersRepository.delete(id);
  }
}
```

---

## üîÑ WebSockets with NestJS

```typescript
// src/gateway/chat.gateway.ts
import {
  WebSocketGateway,
  SubscribeMessage,
  MessageBody,
  WebSocketServer,
  ConnectedSocket,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';

@WebSocketGateway({
  cors: { origin: '*' },
})
export class ChatGateway {
  @WebSocketServer()
  server: Server;

  @SubscribeMessage('message')
  handleMessage(
    @MessageBody() data: { user: string; message: string },
    @ConnectedSocket() client: Socket,
  ): void {
    this.server.emit('message', data);
  }

  handleConnection(client: Socket) {
    console.log(`Client connected: ${client.id}`);
  }

  handleDisconnect(client: Socket) {
    console.log(`Client disconnected: ${client.id}`);
  }
}
```

---

## üì° Scheduling Tasks

```typescript
// src/common/schedulers/cleanup.scheduler.ts
import { Injectable } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';

@Injectable()
export class CleanupScheduler {
  @Cron(CronExpression.EVERY_DAY_AT_MIDNIGHT)
  async cleanupOldLogs() {
    console.log('Running cleanup task...');
    // Cleanup logic
  }

  @Cron('*/5 * * * *') // Every 5 minutes
  async healthCheck() {
    console.log('Health check...');
  }
}
```

---

## üéØ Best Practices Checklist

- [ ] Use modules to organize features
- [ ] Use DTOs with class-validator for validation
- [ ] Use guards for authentication/authorization
- [ ] Use interceptors for cross-cutting concerns
- [ ] Use pipes for data transformation
- [ ] Use filters for exception handling
- [ ] Use TypeORM or Prisma for database
- [ ] Use custom decorators for cleaner code
- [ ] Use environment variables with @nestjs/config
- [ ] Write tests for services and controllers

---

## üìö Common Patterns

### Interceptor for Logging

```typescript
// src/common/interceptors/logging.interceptor.ts
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
  Logger,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  private readonly logger = new Logger(LoggingInterceptor.name);

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const { method, url } = request;
    const now = Date.now();

    return next.handle().pipe(
      tap(() => {
        const response = context.switchToHttp().getResponse();
        const delay = Date.now() - now;
        this.logger.log(
          `${method} ${url} ${response.statusCode} - ${delay}ms`,
        );
      }),
    );
  }
}

// Apply globally
app.useGlobalInterceptors(new LoggingInterceptor());
```

### Exception Filter

```typescript
// src/common/filters/http-exception.filter.ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { Response } from 'express';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const status = exception.getStatus();

    response.status(status).json({
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: ctx.getRequest().url,
      message: exception.message,
    });
  }
}
```

---

## ‚ö†Ô∏è Anti-Patterns

| ‚ùå NEVER | ‚úÖ ALWAYS | Why |
|---------|-----------|-----|
| Logic in controllers | Use services | Controllers should only handle HTTP concerns |
| Direct database access in controllers | Use repositories | Separation of concerns |
| Manual validation without class-validator | Use ValidationPipe + DTOs | Automatic, consistent validation |
| Hardcoded configuration | Use @nestjs/config | Environment-specific settings |
| Business logic in guards | Use services | Guards should only authorize |
| Using `any` type | Use proper TypeScript interfaces | Type safety |
| Static modules for dynamic config | Use DynamicModule | Flexibility |
| Not using dependency injection | Use constructor injection | Testability, decoupling |

---

## üîß Troubleshooting

| Problem | Cause | Solution |
|---------|-------|----------|
| **"Nest can't resolve dependencies"** | Circular dependency or missing import | Use `forwardRef()` for circular deps, check module imports |
| **"ValidationPipe not working"** | Not globally registered or missing decorators | Add `app.useGlobalPipes(new ValidationPipe())` in main.ts |
| **"JWT strategy not called"** | Wrong jwtFromRequest config or secret mismatch | Check ExtractJwt configuration and JWT_SECRET |
| **"Module not found"** | Missing in imports array | Add module to `imports: []` in module file |
| **"Cannot read property of undefined"** | Service not provided in module | Add service to `providers: []` in module |
| **"CORS error"** | CORS not enabled | Call `app.enableCors()` in main.ts |
| **"Database connection failed"** | Wrong connection string or TypeORM config | Check database credentials and config |
| **"Decorator not working"** | Not using reflect-metadata | Import `reflect-metadata` at top of main.ts |

---

## üîó Related Skills

- **Prerequisite:** `typescript-patterns` - NestJS is built on TypeScript
- **Related:** `tech-decisions` - When to choose NestJS vs other frameworks
- **Complementary:** `rust-axum` - Alternative backend framework for performance

---

## üìñ Further Reading

- [Official NestJS Documentation](https://docs.nestjs.com)
- [NestJS CLI Commands](https://docs.nestjs.com/cli/usages)
- [TypeORM with NestJS](https://docs.nestjs.com/techniques/database)
- [Validation with class-validator](https://github.com/typestack/class-validator)

---

## üéØ Success Criteria

NestJS implementation is complete when:
- [ ] Module structure follows feature-based organization
- [ ] All DTOs use class-validator decorators
- [ ] Guards handle authentication/authorization
- [ ] Services contain business logic (not controllers)
- [ ] Global ValidationPipe configured
- [ ] Environment variables use @nestjs/config
- [ ] Custom decorators for common operations
- [ ] Exception filters for consistent error responses
- [ ] Interceptors for cross-cutting concerns
- [ ] Tests for services and controllers

---

## üí° Key Insights

### Why NestJS Works Well

1. **Dependency Injection** - Loose coupling, easy testing
2. **Modular Architecture** - Clear separation of concerns
3. **Decorator-Based** - Declarative, readable code
4. **TypeScript First** - Type safety and better DX
5. **Opinionated Structure** - Consistent patterns across teams

### Common Pitfalls

- ‚ùå **Pitfall:** Putting business logic in controllers
  ‚Üí **Fix:** Move to services, keep controllers thin

- ‚ùå **Pitfall:** Not using modules properly
  ‚Üí **Fix:** One module per feature, import dependencies

- ‚ùå **Pitfall:** Ignoring TypeScript types
  ‚Üí **Fix:** Use interfaces for DTOs and entities

- ‚ùå **Pitfall:** Manual validation
  ‚Üí **Fix:** Use ValidationPipe with class-validator

- ‚ùå **Pitfall:** Not testing services
  ‚Üí **Fix:** Services are easy to test, write unit tests

---

*Version: 2.0.0 | NestJS Patterns*
