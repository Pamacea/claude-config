# TypeScript Patterns & Best Practices

> **Version:** 2.0.0 | **Category:** Cat 4 (Patterns R√©utilisables) | **Difficulty:** Intermediate
> **Auto-Activation:** "typescript", "ts", "type", "interface", "generic", "utility type", "type error"
> **Tags:** [typescript, types, generics, utility-types, type-safety]
> **Related:** nextjs-patterns, nestjs-patterns, tanstack-patterns
> **Last Updated:** 2025-02-24

---

## üöÄ Quick Start

```bash
# Install TypeScript
npm install -D typescript

# Initialize
npx tsc --init

# Run
npx tsc --watch
```

---

## üìä Quick Reference

| Concept | Pattern | Use Case |
|---------|---------|----------|
| **Generics** | `<T>` | Reusable components/functions |
| **Utility Types** | `Partial<T>`, `Pick<T>` | Transform types |
| **Type Guards** | `value is Type` | Runtime type checking |
| **Discriminated Unions** | `{ type: 'a' } \| { type: 'b' }` | Exhaustive checking |
| **Inference** | `infer` | Advanced type manipulation |

---

## üöÄ tsconfig.json Base

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true,
    "skipLibCheck": true,
    "allowJs": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "esModuleInterop": true
  }
}
```

---

## üéØ Utility Types Essentiels

```typescript
// Partial - Tous les champs optionnels
type PartialUser = Partial<User>

// Required - Tous les champs requis
type RequiredUser = Required<User>

// Pick - S√©lectionner certains champs
type UserDTO = Pick<User, 'id' | 'name' | 'email'>

// Omit - Exclure certains champs
type CreateUserDTO = Omit<User, 'id' | 'createdAt'>

// Record - Mapping cl√©/valeur
type Dict<T> = Record<string, T>

// Awaited - Type d'une Promise r√©solue
type Response = Awaited<ReturnType<typeof fetch>>

// Parameters - Types des param√®tres d'une fonction
type Params = Parameters<typeof myFunction>
```

---

## üõ°Ô∏è Type Guards

```typescript
// isString guard
function isString(value: unknown): value is string {
  return typeof value === 'string'
}

// isObject guard
function isObject(value: unknown): value is Record<string, unknown> {
  return typeof value === 'object' && value !== null
}
```

---

## üé® Generic Patterns

```typescript
// API Response wrapper
type ApiResponse<T> = {
  data: T
  status: number
  message: string
}

// Paginated response
type Paginated<T> = {
  items: T[]
  total: number
  page: number
  pageSize: number
}
```

---

## ‚ö†Ô∏è Anti-Patterns

| ‚ùå NEVER | ‚úÖ ALWAYS | Why |
|---------|-----------|-----|
| `any` type | `unknown` or proper type | Type safety is lost |
| `as` casting without validation | Type guards or Zod | Runtime safety |
| `@ts-ignore` | Fix the type error | Suppressing errors causes bugs |
| Optional chaining everywhere | Proper null checks | `?.` hides real issues |
| Duplicating type definitions | Utility types | DRY principle |
| Using `Object` type | `Record<string, T>` | Too permissive |
| Ignoring strict mode | Enable `strict: true` | Catch errors early |
| Not using generics | Proper generic types | Reusability |

---

## üîß Troubleshooting

| Problem | Cause | Solution |
|---------|-------|----------|
| **"Type 'X' is not assignable to 'Y'"** | Mismatched types | Check type definitions, use proper interfaces |
| **"Property 'X' does not exist on type 'Y'"** | Missing type or wrong type | Define interface or use type assertion |
| **"Type 'unknown' is not assignable to..."** | Need type guard | Add type guard before usage |
| **"Cannot find module"** | Missing @types package | Install `@types/package-name` |
| **"TS7053: Element implicitly has 'any' type"** | Missing index signature | Add `Record<string, T>` or key signature |
| **Generic type error** | Wrong generic constraint | Add proper constraint `<T extends SomeType>` |

---

## üîó Related Skills

- **Used by:** `nextjs-patterns` - Next.js uses TypeScript extensively
- **Used by:** `nestjs-patterns` - NestJS is built on TypeScript
- **Used by:** `tanstack-patterns` - TanStack has excellent TS support
- **Related:** `tech-decisions` - TypeScript adoption decisions

---

## üìñ Further Reading

- [Official TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/intro.html)
- [TypeScript Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
- [TypeScript Deep Dive](https://basarat.gitbook.io/typescript/)
- [Total TypeScript](https://totaltypescript.com)

---

## üéØ Success Criteria

TypeScript implementation is complete when:
- [ ] `strict: true` enabled in tsconfig.json
- [ ] Zero `any` types (except specific cases)
- [ ] Proper interfaces/types for all data structures
- [ ] Generics used for reusable code
- [ ] Type guards for runtime validation
- [ ] Utility types leveraged (Partial, Pick, Omit, etc.)
- [ ] No `@ts-ignore` comments
- [ ] Zod or similar for runtime validation

---

## üí° Key Insights

### Why TypeScript Matters

1. **Catch Errors Early** - Compile-time error detection
2. **Better IDE Support** - Autocomplete, inline docs
3. **Self-Documenting** - Types serve as documentation
4. **Refactoring Safety** - Change with confidence
5. **Team Collaboration** - Clear contracts between code

### Common Pitfalls

- ‚ùå **Pitfall:** Using `any` to fix type errors
  ‚Üí **Fix:** Use `unknown` and type guards

- ‚ùå **Pitfall:** Type assertions (`as`) without validation
  ‚Üí **Fix:** Use Zod or runtime checks

- ‚ùå **Pitfall:** Over-complicating types
  ‚Üí **Fix:** Keep types simple, let inference work

- ‚ùå **Pitfall:** Not using strict mode
  ‚Üí **Fix:** Always enable `strict: true`

---

*Version: 2.0.0 | TypeScript Patterns*
