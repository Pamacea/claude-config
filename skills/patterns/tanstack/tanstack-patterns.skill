# TanStack Patterns & Best Practices

> **Version:** 2.0.0 | **Category:** Cat 4 (Patterns RÃ©utilisables) | **Difficulty:** Intermediate
> **Auto-Activation:** "tanstack", "react query", "useQuery", "useMutation", "tanstack router", "tanstack form", "tanstack table"
> **Tags:** [tanstack, react-query, data-fetching, caching, state-management]
> **Related:** nextjs-patterns, typescript-patterns, react-patterns
> **Last Updated:** 2025-02-24

---

## ğŸš€ Quick Start

```bash
# Install TanStack Query
npm install @tanstack/react-query

# Install Router
npm install @tanstack/react-router

# Install Form
npm install @tanstack/react-form

# Install Table
npm install @tanstack/react-table
```

---

## ğŸ“Š Quick Reference

| Tool | Purpose | When to Use |
|------|---------|-------------|
| **TanStack Query** | Server state management | Data fetching, caching, syncing |
| **TanStack Router** | Type-safe routing | Full-stack apps with type safety |
| **TanStack Form** | Form state management | Complex forms with validation |
| **TanStack Table** | Data tables | Sorting, filtering, pagination |

---

## ğŸ“¦ TanStack Query (React Query)

### Basic Usage

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'

function usePosts() {
  return useQuery({
    queryKey: ['posts'],
    queryFn: async () => {
      const res = await fetch('/api/posts')
      return res.json()
    },
    staleTime: 5 * 60 * 1000, // 5 minutes
  })
}
```

### Mutation

```typescript
function useCreatePost() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: async (data: CreatePostInput) => {
      const res = await fetch('/api/posts', {
        method: 'POST',
        body: JSON.stringify(data),
      })
      return res.json()
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['posts'] })
    },
  })
}
```

---

## ğŸ§­ TanStack Router

### File-based Route

```
src/routes/posts.tsx
src/routes/posts.$id.tsx
```

### Loader

```typescript
import { createFileRoute } from '@tanstack/react-router'

export const Route = createFileRoute('/posts/$id')({
  loader: async ({ params }) => {
    const post = await fetchPost(params.id)
    return { post }
  },
  component: Post,
})
```

---

## ğŸ“ TanStack Form

```typescript
import { useForm } from '@tanstack/react-form'

function PostForm() {
  const form = useForm({
    defaultValues: {
      title: '',
      content: '',
    },
    onSubmit: async (values) => {
      await createPost(values)
    },
  })

  return <form {...form.getFormProps()} />
}
```

---

## âš ï¸ Anti-Patterns

| âŒ NEVER | âœ… ALWAYS | Why |
|---------|-----------|-----|
| useEffect for data fetching | useQuery | Automatic caching, loading states, error handling |
| useState for server data | useQuery | Stale data handling, background refetch |
| Manual caching | QueryClient with cacheTime | Built-in intelligent caching |
| Ignoring query keys | Consistent, descriptive keys | Cache invalidation, refetching |
| Not using TypeScript interfaces | Proper type safety | Type inference for data |
| Fetching in useEffect without deps | useQuery with proper deps | Prevents infinite loops |

---

## ğŸ”§ Troubleshooting

| Problem | Cause | Solution |
|---------|-------|----------|
| **"Infinite loop in useEffect"** | Missing deps or fetching in useEffect | Use useQuery instead |
| **"Stale data showing"** | Not using staleTime properly | Set appropriate staleTime |
| **"Query not refetching"** | Wrong queryKey format | Use consistent queryKey array |
| **"Type errors with useQuery"** | Missing generic types | Add `<DataType, ErrorType>` to useQuery |
| **"Form not validating"** | Missing validation adapter | Use validator adapter with Zod |
| **"Table not re-rendering"** | Missing memo or reactMemo | Use proper React optimization |
| **"Router params undefined"** | Wrong route setup | Check file-based routing structure |

---

## ğŸ”— Related Skills

- **Prerequisite:** `typescript-patterns` - TanStack is built with TypeScript
- **Related:** `nextjs-patterns` - TanStack Query pairs perfectly with Next.js
- **Complementary:** `react-patterns` - React hooks and component patterns

---

## ğŸ“– Further Reading

- [Official TanStack Query Docs](https://tanstack.com/query/latest)
- [TanStack Router Docs](https://tanstack.com/router/latest)
- [TanStack Form Docs](https://tanstack.com/form/latest)
- [TanStack Table Docs](https://tanstack.com/table/latest)

---

## ğŸ¯ Success Criteria

TanStack implementation is complete when:
- [ ] Using useQuery for all data fetching (no useEffect)
- [ ] Query keys are consistent and descriptive
- [ ] Proper error handling with error boundaries
- [ ] Using mutations for data updates
- [ ] Cache invalidation configured correctly
- [ ] TypeScript types properly defined
- [ ] Forms using TanStack Form with validation
- [ ] Tables using TanStack Table for complex data

---

## ğŸ’¡ Key Insights

### Why TanStack Works Well

1. **Server State Management** - Separates server from client state
2. **Automatic Caching** - Intelligent stale-while-revalidate
3. **Background Refetching** - Keep data fresh automatically
4. **Type Safety** - Full TypeScript support
5. **Developer Experience** - Excellent DevTools

### Common Pitfalls

- âŒ **Pitfall:** Using useEffect for data fetching
  â†’ **Fix:** Always use useQuery for server state

- âŒ **Pitfall:** Not handling loading/error states
  â†’ **Fix:** Destructure `{ isLoading, error, data }` from useQuery

- âŒ **Pitfall:** Inconsistent query keys
  â†’ **Fix:** Use consistent key structure like `['posts', id]`

- âŒ **Pitfall:** Not invalidating cache after mutations
  â†’ **Fix:** Use `queryClient.invalidateQueries()` in onSuccess

---

*Version: 2.0.0 | TanStack Patterns*
