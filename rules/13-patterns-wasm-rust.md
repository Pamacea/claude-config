# Rust + WebAssembly Patterns & Best Practices

> **Version:** 5.0.0 | **wasm-bindgen, wasm-pack, Next.js integration**

---

## ðŸš€ Quick Start

```bash
# Create new WASM package
cargo new --lib my-wasm-lib
cd my-wasm-lib

# Add WASM dependencies
cargo add wasm-bindgen wasm-bindgen-rayon js-sys web-sys

# Build
wasm-pack build --target web

# Or in Next.js project
npm install wasm-pack
```

### Cargo.toml Configuration

```toml
[package]
name = "my-wasm-lib"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
wasm-bindgen = "0.2"
js-sys = "0.3"
web-sys = "0.3"

# Optional: For parallel processing
wasm-bindgen-rayon = { version = "1.1", optional = true }

[dependencies.wee_alloc]
version = "0.4.5"
optional = true

[features]
default = ["wee_alloc"]

# Optimize for size
[profile.release]
opt-level = "z"
lto = true
codegen-units = 1
```

---

## ðŸ“ Project Structure

```
my-wasm-lib/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ Cargo.lock
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs              # Main entry point
â”‚   â”œâ”€â”€ utils.rs            # Utility functions
â”‚   â””â”€â”€ processing.rs       # Core logic
â”œâ”€â”€ pkg/                    # Generated by wasm-pack
â”‚   â”œâ”€â”€ my_wasm_lib.js
â”‚   â”œâ”€â”€ my_wasm_lib_bg.wasm
â”‚   â””â”€â”€ my_wasm_lib.d.ts
â””â”€â”€ www/                    # For testing
    â”œâ”€â”€ index.html
    â”œâ”€â”€ package.json
    â””â”€â”€ index.js
```

### With Next.js Integration

```
my-nextjs-app/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â””â”€â”€ WasmComponent.tsx
â”‚   â””â”€â”€ lib/
â”‚       â””â”€â”€ wasm/
â”‚           â”œâ”€â”€ pkg/        # Generated WASM
â”‚           â””â”€â”€ loader.ts   # WASM loader
â”œâ”€â”€ wasm-lib/               # Rust source
â”‚   â”œâ”€â”€ Cargo.toml
â”‚   â””â”€â”€ src/
â”‚       â””â”€â”€ lib.rs
â””â”€â”€ package.json
```

---

## ðŸŽ¯ Basic Patterns

### Hello World

```rust
// src/lib.rs
use wasm_bindgen::prelude::*;

// Export a function to JavaScript
#[wasm_bindgen]
pub fn greet(name: &str) -> String {
    format!("Hello, {}!", name)
}

// Export a const
#[wasm_bindgen]
pub const VERSION: &str = "1.0.0";
```

### Using in JavaScript

```typescript
import init, { greet, VERSION } from './my-wasm-lib/pkg'

async function main() {
  await init(); // Always call init first!
  console.log(VERSION); // "1.0.0"
  console.log(greet("World")); // "Hello, World!"
}

main()
```

### Using in React Component

```typescript
// components/WasmComponent.tsx
'use client'

import { useEffect, useState } from 'react'
import init, { greet } from '@/lib/wasm/pkg/my_wasm_lib'

export function WasmComponent() {
  const [message, setMessage] = useState('Loading...')

  useEffect(() => {
    async function loadWasm() {
      await init()
      setMessage(greet('React'))
    }
    loadWasm()
  }, [])

  return <div>{message}</div>
}
```

---

## ðŸ“Š Working with Complex Data

### Return Objects

```rust
use wasm_bindgen::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize)]
#[wasm_bindgen]
pub struct Point {
    x: f64,
    y: f64,
}

#[wasm_bindgen]
impl Point {
    #[wasm_bindgen(constructor)]
    pub fn new(x: f64, y: f64) -> Point {
        Point { x, y }
    }

    pub fn distance(&self, other: &Point) -> f64 {
        let dx = self.x - other.x;
        let dy = self.y - other.y;
        (dx * dx + dy * dy).sqrt()
    }
}
```

### Working with Arrays

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn sum_array(numbers: &[f64]) -> f64 {
    numbers.iter().sum()
}

#[wasm_bindgen]
pub fn double_array(numbers: Vec<f64>) -> Vec<f64> {
    numbers.into_iter().map(|x| x * 2.0).collect()
}

// For large arrays, use TypedArrays
#[wasm_bindgen]
pub fn process_float32_array(input: &[f32]) -> Vec<f32> {
    input.iter().map(|x| x * 2.0).collect()
}
```

### JavaScript Interop

```rust
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsCast;

#[wasm_bindgen]
extern "C" {
    // Access browser console
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);

    // Access window
    #[wasm_bindgen(js_namespace = window)]
    fn innerWidth() -> f32;
}

#[wasm_bindgen]
pub fn log_from_rust(message: &str) {
    log(message);
}

#[wasm_bindgen]
pub fn get_window_width() -> f32 {
    innerWidth()
}
```

---

## ðŸ§µ Parallel Processing with Rayon

### Setup

```toml
[dependencies]
wasm-bindgen-rayon = "1.1"
rayon = "1.10"
```

### Parallel Processing

```rust
use wasm_bindgen::prelude::*;
use wasm_bindgen_rayon::init_thread_pool;

#[wasm_bindgen]
pub fn init_rayon() {
    init_thread_pool(num_cpus::get());
}

#[wasm_bindgen]
pub fn parallel_process(data: Vec<f64>) -> Vec<f64> {
    use rayon::prelude::*;

    data.par_iter()
        .map(|x| x * x)
        .collect()
}

// Or with slices for better performance
#[wasm_bindgen]
pub fn parallel_process_slice(input: &[f64]) -> Vec<f64> {
    use rayon::prelude::*;

    input.par_iter()
        .map(|x| x.sqrt())
        .collect()
}
```

### JavaScript Integration

```javascript
import init, { init_rayon, parallel_process } from './pkg';

await init();
await init_rayon(); // Must call before parallel functions!

const data = new Float64Array([1, 2, 3, 4, 5]);
const result = parallel_process(data);
```

---

## ðŸ–¼ï¸ Image Processing Example

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn grayscale(image_data: &[u8], width: u32, height: u32) -> Vec<u8> {
    let mut result = image_data.to_vec();

    for i in (0..image_data.len()).step_by(4) {
        let r = image_data[i] as f32;
        let g = image_data[i + 1] as f32;
        let b = image_data[i + 2] as f32;

        // Standard grayscale formula
        let gray = (0.299 * r + 0.587 * g + 0.114 * b) as u8;

        result[i] = gray;
        result[i + 1] = gray;
        result[i + 2] = gray;
        // Alpha channel unchanged
    }

    result
}

#[wasm_bindgen]
pub fn invert_colors(image_data: &[u8]) -> Vec<u8> {
    image_data
        .iter()
        .map(|&byte| 255 - byte)
        .collect()
}
```

### Using in React with Canvas

```typescript
'use client'

import { useRef, useEffect } from 'react'
import init, { grayscale } from '@/lib/wasm/pkg/image_processor'

export function ImageEditor() {
  const canvasRef = useRef<HTMLCanvasElement>(null)

  useEffect(() => {
    init()
  }, [])

  const applyGrayscale = async () => {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext('2d')
    if (!ctx) return

    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
    const input = new Uint8Array(imageData.data.buffer)

    // Process in WASM
    const output = await grayscale(input, canvas.width, canvas.height)

    const resultImageData = new ImageData(
      new Uint8ClampedArray(output.buffer),
      canvas.width,
      canvas.height
    )

    ctx.putImageData(resultImageData, 0, 0)
  }

  return (
    <div>
      <canvas ref={canvasRef} width={800} height={600} />
      <button onClick={applyGrayscale}>Apply Grayscale</button>
    </div>
  )
}
```

---

## ðŸŽ® Game Loop Pattern

```rust
use wasm_bindgen::prelude::*;
use web_sys::{CanvasRenderingContext2d, window};
use js_sys::Uint8Array;

#[wasm_bindgen]
pub struct Game {
    width: u32,
    height: u32,
    pixels: Vec<u8>,
}

#[wasm_bindgen]
impl Game {
    #[wasm_bindgen(constructor)]
    pub fn new(width: u32, height: u32) -> Game {
        let pixels = vec
![0; (width * height * 4)
as usize];
        Game { width, height, pixels }
    }

    pub fn update(&mut self) {
        // Update game state
        for i in (0..self.pixels.len()).step_by(4) {
            self.pixels[i] = ((i as f32 / self.pixels.len() as f32) * 255.0) as u8;
        }
    }

    pub fn render(&self, canvas_id: &str) -> Result<(), JsValue> {
        let document = window()
?.document()
?;
        let canvas = document.get_element_by_id(canvas_id)?
            .dyn_into::<web_sys::HtmlCanvasElement>()?;
        let ctx = canvas
            .get_context("2d")?
            .unwrap()
            .dyn_into::<CanvasRenderingContext2d>()?;

        let image_data = web_sys::ImageData::new_with_u8_and_sh(
            self.width,
            self.height,
            &Uint8Array::from(&self.pixels[..]),
        )?;

        ctx.put_image_data(&image_data, 0.0, 0.0)
    }
}
```

---

## ðŸ” Cryptography Example

```toml
[dependencies]
sha2 = "0.10"
hex = "0.4"
```

```rust
use wasm_bindgen::prelude::*;
use sha2::{Sha256, Digest};
use hex;

#[wasm_bindgen]
pub fn hash_string(input: &str) -> String {
    let mut hasher = Sha256::new();
    hasher.update(input.as_bytes());
    let result = hasher.finalize();
    hex::encode(result)
}

#[wasm_bindgen]
pub fn hash_bytes(input: &[u8]) -> Vec<u8> {
    let mut hasher = Sha256::new();
    hasher.update(input);
    hasher.finalize().to_vec()
}
```

---

## ðŸ“¦ Next.js Integration

### Optimized WASM Loader

```typescript
// lib/wasm/loader.ts
import { useEffect, useState } from 'react'

type WasmModule = {
  readonly memory: WebAssembly.Memory
  readonly [key: string]: any
}

let wasmCache: WasmModule | null = null

export async function loadWasm<T extends WasmModule>(
  modulePath: string,
  initFn: () => Promise<T>
): Promise<T> {
  if (wasmCache) {
    return wasmCache as T
  }

  const module = await initFn()
  wasmCache = module
  return module
}

// React Hook
export function useWasm<T extends WasmModule>(
  modulePath: string,
  initFn: () => Promise<T>
) {
  const [module, setModule] = useState<T | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  useEffect(() => {
    loadWasm(modulePath, initFn)
      .then(setModule)
      .catch(setError)
      .finally(() => setLoading(false))
  }, [modulePath, initFn])

  return { module, loading, error }
}
```

### Usage in Next.js

```typescript
// app/page.tsx
'use client'

import dynamic from 'next/dynamic'

// Disable SSR for WASM
const WasmProcessor = dynamic(
  () => import('@/components/WasmProcessor'),
  { ssr: false }
)

export default function Page() {
  return (
    <main>
      <h1>WASM Image Processing</h1>
      <WasmProcessor />
    </main>
  )
}
```

---

## ðŸŽ¯ Best Practices

### Performance

1. **Minimize JS/Wasm Boundaries**
   - Batch operations
   - Pass arrays instead of individual values
   - Use TypedArrays for large data

2. **Optimize WASM Size**
   ```bash
   # Use wasm-opt to optimize
   wasm-opt pkg/my_wasm_lib_bg.wasm -O4 -o pkg/my_wasm_lib_bg_opt.wasm

   # Enable LTO in Cargo.toml
   [profile.release]
   lto = true
   opt-level = "z"
   ```

3. **Use Shared Memory**
   ```rust
   use wasm_bindgen::prelude::*;

   #[wasm_bindgen]
   pub fn process_shared_memory(ptr: *mut u8, len: usize) {
       let slice = unsafe { std::slice::from_raw_parts_mut(ptr, len) };
       // Process in place
   }
   ```

### Memory Management

```rust
// For large allocations, consider explicit allocation
#[wasm_bindgen]
pub fn allocate_large_buffer(size: usize) -> *mut u8 {
    let mut buffer = vec
![0u8; size]
    let ptr = buffer.as_mut_ptr();
    std::mem::forget(buffer); // Prevent deallocation
    ptr
}

#[wasm_bindgen]
pub fn free_buffer(ptr: *mut u8, size: usize) {
    unsafe {
        let _ = Vec::from_raw_parts(ptr, size, size);
    }
}
```

### Error Handling

```rust
use wasm_bindgen::prelude::*;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum WasmError {
    #[error("Invalid input: {0}")]
    InvalidInput(String),

    #[error("Processing failed")]
    ProcessingFailed,
}

#[wasm_bindgen]
pub fn safe_process(input: &str) -> Result<String, JsValue> {
    if input.is_empty() {
        return Err(WasmError::InvalidInput("Empty input".to_string())
).into());
    }
    Ok(input.to_uppercase())
}
```

---

## ðŸ§ª Testing WASM

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_greet() {
        assert_eq!(greet("World"), "Hello, World!");
    }

    #[test]
    fn test_sum_array() {
        let input = vec
![1.0, 2.0, 3.0, 4.0, 5.0];
        assert_eq!(sum_array(&input)
, 15.0);
    }
}
```

---

## ðŸŽ¯ Checklist

- [ ] Use `#[wasm_bindgen]` for exported functions
- [ ] Initialize with `await init()` before using
- [ ] Use TypedArrays for large data transfer
- [ ] Minimize JS/Wasm boundary crossings
- [ ] Optimize WASM size with wasm-opt
- [ ] Use Rayon for parallel processing
- [ ] Handle errors with Result types
- [ ] Test in browser (Node.js WASM is different)
- [ ] Disable SSR in Next.js (`ssr: false`)
- [ ] Cache loaded WASM module

---

## ðŸ“š Resources

- **wasm-bindgen:** https://rustwasm.github.io/wasm-bindgen/
- **wasm-pack:** https://rustwasm.github.io/wasm-pack/
- **Rust WASM Book:** https://rustwasm.github.io/docs/book/

---

*Version: 5.0.0*
